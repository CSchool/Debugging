\documentclass[14pt,openany]{book}

\include{preamble}

\begin{document}

\begingroup
\hypersetup{linkcolor=black}
\tableofcontents
\endgroup

\clearpage

\chapter{Принципы тестирования и отладки}

Тестирование --- выполнение программы с целью обнаружения ошибок.

Отладка --- определение места ошибки и внесение исправлений в программу.

Ошибки в программе есть всегда.

Тест --- это совокупность исходных данных и ожидаемых результатов.

Необходимо фиксировать выполненные тесты и реально полученные результаты.

Необходимо проверять что программа делает то, что нужно и что программа
не делает того, чего не нужно.

После исправления программы необходимо повторное тестирование.

Ошибка --- место в программе, где программст написал некорректный код.

Сбой --- неверная работа в программе.

Код, вызывающий сбой и код, содержащий ошибку как правило не один и тот же.

\chapter{Как тестировать свою программу}

\section{Критерии тестирования}

\subsection{Критерий покрытия путей}

Нужно покрыть все возможные пути в программе. 

\begin{lstlisting}
if (a == 0)
  std::cout << "1";
if (b == 0)
  std::cout << "2";
if (c == 0)
  std::cout << "3";
\end{lstlisting}

Сколько вариантов вывода?

\begin{lstlisting}
while (a != 0)
{
    int b;
    std::cin >> b;
    a += b;
}
\end{lstlisting}

Разных путей бесконечно много из-за непредсказуемости пользовательского ввода.

Поэтому критерий покрытия путей невозмножно применить на практике.

\subsection{Критерий покрытия ветвей}

Нужно стараться покрыть все ветви программы тестами.

\begin{lstlisting}
if (a == 0)
  std::cout << "1";
if (b == 0)
  std::cout << "2";
if (c == 0)
  std::cout << "3";
\end{lstlisting}

Тест $a=0, b=0, c=0$ покрывает все ветви.


\begin{lstlisting}
if (a == 0)
  std::cout << "1";
else
  std::cout << "-1";
if (b == 0)
  std::cout << "2";
else
  std::cout << "-2";
if (c == 0)
  std::cout << "3";
else
  std::cout << "-3";
\end{lstlisting}

Нужно минимум 2 теста. Например, $a=0, b=0, c=0$ и $a=1, b=1, c=1$.

\begin{lstlisting}
if (a != 0 || c != 0)
  std::cout << c / a;
else
  std::cout << "0";
\end{lstlisting}

Здесь обе ветки можно покрыть с помощью тестов $a=1, c=1$ и $a=0, c=0$.
Однако, возможность получить ошибку деления на $0$ не проверена с помощью
теста $a=0, c=1$.

\subsection{Критерий покрытия условий}

Чтобы каждая часть условия получила истинное или ложное
значение хотя бы один раз.

Предыдущий пример иллюстрирует необходимость покрытия разных комбинаций простых
условий в составном.

Модифицированный критерий покрытия условий --- критерий комбинаторного покрытия условий.
Требует, чтобы хотя бы один раз выполнялась каждая комбинация простых условий.

\subsection{Как придумывать тесты}

Граничные значения: минимальные и максимальные значения параметров, максимальное время выполнения,
максимальная используемая память.

Особенные для алгоритма значения: чтобы выполнялся один из критериев покрытия тестами.

\section{Задания}

Дана программа. Придумать тесты, записать в таблицу входные и выходные данные.
Объяснить результаты.

\chapter{Методы отладки}

\begin{lstlisting}
a = 0;
if (x > 3)
  a = 10;
b = 100 / a;
\end{lstlisting}

Четвёртая строка программы --- место проявления ошибки.
Местом нахождения ошибки могут быть:
\begin{itemize}
\item первая строка, где переменная инициализируется
\item вторая строка с неправильным условием
\item третья строка, где отсутствует ветка <<иначе>>
\item четвёртая строка, где записано неправильное выражение
\end{itemize}

С помощью тестов можно обнаружить только место проявления ошибки.


Последовательность отладки:
Найти тест, вызывающий сбой
Уменьшить тест, чтобы происходил тот же самый сбой
Локализовать место, содержащее ошибку

\section{Отладочный вывод}

\section{Утверждения}

\section{Принципы отладки}

\begin{itemize}
\item Обдумывать результаты каждого теста
\item Не вносить случайные исправления
\item Проверять тестами конкретные гипотезы
\item Исправлять ошибки по очереди
\item Постараться объяснить все видимые симптомы сбоя
\item Исправление может внести новые ошибки
\end{itemize}

\section{Отладчики}

\chapter{Интерактивный отладчик Visual Studio}

Пошаговое исполнение
Исполнение <<до курсора>>
Просмотр значений переменных
Точки прерывания
Точки трассировки
Точки наблюдения
Наблюдение за стеком

\chapter{Наиболее часто встречающиеся ошибки}

\section{Использование неинициализированной переменной}

Иногда может быть обнаружена на этапе компиляции.
Часто приводит к неожиданному поведению программы, которое меняется от запуска
к запуску. 

\section{Неверно инициализированные переменные}

Если переменная объявлена глобально, она заполняется нулями, что не всегда подходит.

\section{Выход за границы массива}

Обращение к массиву очень сложно проконтролировать в C/C++.

\section{Использование указателей на освобождённую память}

Динамическая память может быть уже заполнена другими данными.

\section{Ошибки с приоритетами операций}

\section{Неправильная вложенность условных операторов}

\begin{lstlisting}
if (A)
  if (B)
    X;
else
  Y;
\end{lstlisting}

\chapter{Конкурс по отладке программ}

\end{document} 
